# ZSBL - Zero Stage Boot Loader

Загрузчик первого уровня для компьютерной системы на базе RISC-V (RV32I).

## Назначение

ZSBL выполняет следующие функции:

1. **Инициализация системы** - обнуление регистров, настройка стека
2. **Тестирование компонентов** - последовательная проверка периферии
3. **Передача управления** - запуск основной программы из SRAM

## Карта памяти

| Адрес        | Размер | Назначение                              |
|--------------|--------|-----------------------------------------|
| `0x00001000` | 64 KB  | ROM - код загрузчика ZSBL               |
| `0x00011000` | 4 KB   | OnChip RAM - стек загрузчика            |
| `0x02000000` | 20 KB  | SRAM - область основной программы       |
| `0x03000000` | -      | HEX Display - 7-сегментные индикаторы   |
| `0x08000000` | -      | SDRAM - внешняя память                  |
| `0x10000000` | -      | UART - последовательный порт (115200 8N1)|
| `0x10060000` | -      | GPIO - порты ввода/вывода               |

## Последовательность загрузки

```
┌─────────────────────────────────────────────────────────┐
│                    ZSBL Boot Sequence                    │
├─────────────────────────────────────────────────────────┤
│  1. Reset → _start (0x00001000)                         │
│  2. Инициализация регистров x1-x31 = 0                  │
│  3. Настройка стека (sp → 0x00012000)                   │
│  4. Вызов _bios_ini_c()                                 │
│     ├── test_uart()      → Инициализация UART           │
│     ├── test_gpio()      → Проверка GPIO пинов          │
│     ├── test_sram()      → Тест памяти паттернами       │
│     ├── test_hex_display() → Тест 7-сегм. дисплея       │
│     └── check_and_jump_to_program()                     │
│          ├── [magic OK] → Jump to 0x02000004            │
│          └── [magic FAIL] → Halt (WFI loop)             │
└─────────────────────────────────────────────────────────┘
```

## Тесты компонентов

### UART
- Инициализация на скорости 115200 бод
- Вывод заголовка тестов

### GPIO  
- Последовательное чтение всех 22 пинов (4 + 18)
- Запись прочитанных значений обратно

### SRAM (Отключен, чтобы не перезаписывать основную программу)
- Тестирование 20 KB памяти начиная с `0x02000000`
- Паттерны: `0x00`, `0xFF`, `0xAA`, `0x55`
- При ошибке выводится адрес и ожидаемое/полученное значение

### HEX Display
- Запись тестовых значений `0x55` и `0xAA`

## Формат основной программы

Для передачи управления основная программа должна иметь следующий формат:

```
Адрес       │ Содержимое
────────────┼─────────────────────────────────
0x02000000  │ Magic Number: 0x52564D00 ("RVM\0")
0x02000004  │ Первая инструкция программы
0x02000008  │ ...
```

### Magic Number

- Значение: `0x52564D00`
- Расшифровка: "RVM" (RISC-V Machine) + нулевой байт
- Назначение: валидация наличия корректной программы

### Точка входа

- Адрес: `0x02000004` (сразу после magic number)
- Вызов: как функция без аргументов `void entry(void)`
- Возврат: не предусмотрен

## Пример вывода

```
=== ZSBL Boot Tests ===
[UART] OK
[GPIO] OK
[SRAM] OK
[HEX ] OK
=======================
All tests passed.

Valid program found at SRAM.
Jumping to 0x02000004...
```

При отсутствии программы:

```
=== ZSBL Boot Tests ===
[UART] OK
[GPIO] OK
[SRAM] OK
[HEX ] OK
=======================
All tests passed.

No valid program in SRAM (magic: 0x00000000, expected: 0x52564D00)
Halting.
```

## Сборка

### Требования

- RISC-V GCC Toolchain (`riscv64-unknown-elf-gcc`)
- Python 3 (для генерации .mif файлов)
- GNU Make

### Команды

```bash
# Полная сборка
make

# Пересборка
make remake

# Очистка
make clean
```

### Выходные файлы

| Файл              | Описание                           |
|-------------------|------------------------------------|
| `bin/boot`        | ELF-файл загрузчика                |
| `bin/boot.hex`    | HEX-файл для программирования      |
| `bin/boot.mif`    | MIF-файл для Quartus               |
| `bin/boot.objdump`| Дизассемблированный листинг        |

## Параметры конфигурации

Через Makefile можно изменить:

```makefile
SYSTEMCLOCK   ?= 50000000    # Частота системы (Гц)
MAXSDCCLOCK   ?=  5000000    # Макс. частота SD-карты (Гц)
EXT_MEM_BASE  ?= 0x80000000  # Базовый адрес внешней памяти
EXT_MEM_RANGE ?= 0x10000000  # Размер внешней памяти
```

## Структура проекта

```
zsbl/
├── Makefile            # Система сборки
├── README.md           # Документация (этот файл)
├── hex2mif/
│   └── hex2mif.py      # Конвертер HEX → MIF
└── src/
    ├── bios.S          # Точка входа (ассемблер)
    ├── bios_ini.c      # Основная логика загрузчика
    ├── bios_ini.h      # Заголовок bios_ini
    ├── gpiolib.h       # Драйвер GPIO
    ├── linker1000.x    # Скрипт линкера
    ├── riscv.h         # RISC-V утилиты (заголовок)
    ├── riscv.S         # RISC-V утилиты (ассемблер)
    ├── system.h        # Системные константы
    ├── uart.c          # Драйвер UART
    └── uart.h          # Заголовок UART
```

## Создание основной программы

Пример минимальной программы для SRAM:

```c
// main_program.c
#define PROGRAM_MAGIC 0x52564D00

__attribute__((section(".magic")))
const unsigned int magic = PROGRAM_MAGIC;

__attribute__((section(".text")))
void _start(void) {
    // Ваш код здесь
    while(1);
}
```

Скрипт линкера для основной программы:

```ld
MEMORY {
  SRAM (rwx) : ORIGIN = 0x02000000, LENGTH = 20K
}

SECTIONS {
  .magic : { *(.magic) } > SRAM
  .text  : { *(.text*) } > SRAM
  .data  : { *(.data*) } > SRAM
  .bss   : { *(.bss*)  } > SRAM
}
```